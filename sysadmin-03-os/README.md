1. Какой системный вызов делает команда cd? В прошлом ДЗ мы выяснили, что cd не является самостоятельной программой, 
   это shell builtin, поэтому запустить strace непосредственно на cd не получится. Тем не менее, вы можете запустить 
   strace на /bin/bash -c 'cd /tmp'. В этом случае вы увидите полный список системных вызовов, которые делает сам bash 
   при старте. Вам нужно найти тот единственный, который относится именно к cd. Обратите внимание, что strace выдаёт 
   результат своей работы в поток stderr, а не в stdout.
   
   In: strace sh -c 'cd /tmp'
   
   Системный вызов, который делает команда cd:
   
   Out: 
   
   ...
   
   chdir("/tmp")                           = 0
   

2. Попробуйте использовать команду file на объекты разных типов на файловой системе. Например:

	vagrant@netology1:~$ file /dev/tty
	
	/dev/tty: character special (5/0)
	
	vagrant@netology1:~$ file /dev/sda
	
	/dev/sda: block special (8/0)
	
	vagrant@netology1:~$ file /bin/bash
	
	/bin/bash: ELF 64-bit LSB shared object, x86-64
	
   Используя strace выясните, где находится база данных file на основании которой она делает свои догадки.

	In: strace sh -c 'file /dev/tty'
	
	Out: 
    
	...
    
	stat("/usr/bin/file", {st_mode=S_IFREG|0755, st_size=27104, ...}) = 0
	
	Аналогично при использовании file на других объектах из задания.
	Т.е. база данных file находится в /usr/bin/file

3. Предположим, приложение пишет лог в текстовый файл. Этот файл оказался удален (deleted в lsof), однако возможности 
   сигналом сказать приложению переоткрыть файлы или просто перезапустить приложение – нет. Так как приложение продолжает 
   писать в удаленный файл, место на диске постепенно заканчивается. Основываясь на знаниях о перенаправлении потоков 
   предложите способ обнуления открытого удаленного файла (чтобы освободить место на файловой системе).

	In: lsof -p 181248 | grep do_not_delete_me
	
	python3 181248 vagrant 3r REG 253,0 14 1572876 /tmp/do_not_delete_me (deleted)
	
	In: cat /dev/null >/proc/181248/fd/3

4. Занимают ли зомби-процессы какие-то ресурсы в ОС (CPU, RAM, IO)?

	Процесс при завершении (как нормальном, так и в результате не обрабатываемого сигнала) освобождает все свои ресурсы и 
	становится «зомби» — пустой записью в таблице процессов, хранящей статус завершения, предназначенный для чтения 
	родительским процессом. Зомби-процесс существует до тех пор, пока родительский процесс не прочитает его статус с 
	помощью системного вызова wait(), в результате чего запись в таблице процессов будет освобождена.

5. В iovisor BCC есть утилита opensnoop:

	root@vagrant:~# dpkg -L bpfcc-tools | grep sbin/opensnoop
	
	/usr/sbin/opensnoop-bpfcc
	
   На какие файлы вы увидели вызовы группы open за первую секунду работы утилиты? Воспользуйтесь пакетом bpfcc-tools 
   для Ubuntu 20.04. Дополнительные сведения по установке.
   
   In: sudo /usr/sbin/opensnoop-bpfcc

   Out:
   
   PID    COMM               FD ERR PATH
   
   1028   vminfo              4   0 /var/run/utmp
   
   587    dbus-daemon        -1   2 /usr/local/share/dbus-1/system-services
   
   587    dbus-daemon        18   0 /usr/share/dbus-1/system-services
   
   587    dbus-daemon        -1   2 /lib/dbus-1/system-services
   
   587    dbus-daemon        18   0 /var/lib/snapd/dbus-1/system-services/
   
6. Какой системный вызов использует uname -a? Приведите цитату из man по этому системному вызову, где описывается 
   альтернативное местоположение в /proc, где можно узнать версию ядра и релиз ОС.
   
   Part of the utsname information is also accessible  via  /proc/sys/kernel/{ostype, hostname, osrelease, version, domainname}
   
   
7. Чем отличается последовательность команд через ; и через && в bash? Например:

	root@netology1:~# test -d /tmp/some_dir; echo Hi
	
	Hi
	
	root@netology1:~# test -d /tmp/some_dir && echo Hi
	
	root@netology1:~#
	
   Есть ли смысл использовать в bash &&, если применить set -e?
   
   Команды, разделенные через ; выполняются последовательно справа налево.
   
   Команды, разделенные логическим оператором && выполняются, только при условии true обоих команд.
   
   То есть, чтобы в примере test -d /tmp/some_dir && echo Hi выполнилась команда echo Hi, надо, 
   чтобы успешно отработала команда test -d /tmp/some_dir
   
   Параметр -e команды set указывает оболочке выйти, если команда дает ненулевой статус выхода. Проще говоря, оболочка завершает работу 
   при сбое команды. Поэтому нет смысла использовать еще и &&
   
8. Из каких опций состоит режим bash set -euxo pipefail и почему его хорошо было бы использовать в сценариях?

	-e указывает оболочке выйти, если команда дает ненулевой статус выхода
	
	-u обрабатывает неустановленные или неопределенные переменные, за исключением специальных параметров, 
	   таких как подстановочные знаки (*) или «@», как ошибки во время раскрытия параметра
	   
	-x печатает аргументы команды во время выполнения
	
	Директива set -e не работает при работе с конвейерными командами. Когда запускаетcя сценарий и он возвращает ошибку, 
	то все равно продолжает выполнять следующую команду. Чтобы преодолеть это препятствие, надо передать директиву 
	set -eo pipefail. Тогда сценарий завершается и не выполняет следующую строку.
	
	По сути хорошо использовать эту команду для поиска ошибок и логирования в сценариях.

9. Используя -o stat для ps, определите, какой наиболее часто встречающийся статус у процессов в системе. 
   В man ps ознакомьтесь (/PROCESS STATE CODES) что значат дополнительные к основной заглавной буквы статуса процессов. 
   Его можно не учитывать при расчете (считать S, Ss или Ssl равнозначными).
   
   Наиболее популярный статус у процессов S (interruptible sleep), а именно S, Ss, Ssl
   
   Дополнительные буквы означают:
   
   s    is a session leader
   
   l    is multi-threaded
   
   +    is in the foreground process group
   
  
